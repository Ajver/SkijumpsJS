SJ.AirSystem=class{constructor(){this.angle=random()*TWO_PI,this.airForce=random(SJ.variables.airMinForce,SJ.variables.airMaxForce)}update(){if(this.angle+=this.getAngleMod(),SJ.ui.updateAirAngle(this.angle),SJ.jumper.body.isStatic)return;const forceVector=this.calculateAerodynamicForce(),newVelocity=Matter.Vector.add(SJ.jumper.body.velocity,forceVector);Matter.Body.setVelocity(SJ.jumper.body,newVelocity);const rotateForce=this.calculateJumperRotateForce(),newAngularVelocity=(SJ.jumper.body.angularVelocity+rotateForce)*SJ.variables.jumperAngularFriction;Matter.Body.setAngularVelocity(SJ.jumper.body,newAngularVelocity)}getAngleMod(){const changeAbout=.1*pow(random(),6),tempAngle=this.angle+QUARTER_PI,directionMod=abs(.5*sin(tempAngle))+.1,changeDir=random()-directionMod;return changeDir*changeAbout}calculateAerodynamicForce(){const relativeVelocity=this.getRelativeVelocity(),relVelSqr=Matter.Vector.magnitudeSquared(relativeVelocity),liftMod=1;let force=SJ.variables.airDensity*relVelSqr*1*.5,forceAngle=this.getVectorAngle(relativeVelocity)-HALF_PI;const forceVector=this.getVectorFromAngle(forceAngle,force);return forceVector}getRelativeVelocity(){const airVelocity=this.getAirVelocity();return Matter.Vector.sub(SJ.jumper.body.velocity,airVelocity)}getAirVelocity(){return this.getVectorFromAngle(this.angle,this.airForce)}calculateJumperRotateForce(){const relativeAngle=this.getRelativeAngle();let rotateForce=Matter.Vector.magnitude(this.getRelativeVelocity())*SJ.variables.airDensity;return rotateForce=min(rotateForce,1),relativeAngle*(rotateForce=max(rotateForce,-1))}getRelativeAngle(){let relativeAngle=SJ.jumper.body.angle-(this.angle-HALF_PI);for(;relativeAngle>PI;)relativeAngle-=PI;return relativeAngle/=PI}getVectorAngle(vector){return atan2(vector.y,vector.x)}getVectorFromAngle(angle,length=1){const x=cos(angle)*length,y=sin(angle)*length;return Matter.Vector.create(x,y)}};