SJ.PadPart=class{constructor(p1,p2,img,imgWidth){this.x=p1.x,this.y=p1.y,this.img=img;const distance=dist(p1.x,p1.y,p2.x,p2.y);this.scale=1.7,this.scale=distance/imgWidth;const diffX=p2.x-p1.x,diffY=p2.y-p1.y;this.rotate=atan2(diffY,diffX),this.offset={x:-10,y:-26*this.scale}}draw(){push(),translate(this.x,this.y),rotate(this.rotate),translate(this.offset.x,this.offset.y),scale(this.scale),image(this.img,0,0),pop()}},SJ.PadCreator={SQRT_3:1.7320508,padImg:null,loadImages:()=>{SJ.PadCreator.padImg=SJ.ImageLoader.load(SJ.V.texturesNames.pad),SJ.PadCreator.padDescentImg=SJ.ImageLoader.load("descent-part.png"),SJ.PadCreator.padPartImg=SJ.ImageLoader.load("pad-part.png"),SJ.PadCreator.padEndImg=SJ.ImageLoader.load("pad-end.png")},createPadBody:()=>(PAD_PULLING_POINTS=SJ.V.padPullingPoints,PAD_COLLISION_POINTS=SJ.PadCreator.generatePadCollisionPoints(),JUMP_POINT=SJ.V.jumpStartPoint,JUMP_END_POINT=PAD_PULLING_POINTS[PAD_PULLING_POINTS.length-1].x,FALL_LINE=PAD_COLLISION_POINTS[PAD_COLLISION_POINTS.length-2].x,Matter.Body.create({isStatic:!0,parts:SJ.PadCreator.createParts()})),generatePadCollisionPoints:()=>{const scales=SJ.V.padShapeScalars;let points=[];const step=.05,offsetPoint_x=PAD_PULLING_POINTS[PAD_PULLING_POINTS.length-1].x,offsetPoint_y=PAD_PULLING_POINTS[PAD_PULLING_POINTS.length-1].y+90;for(let x=0;x<=1;x+=.05){const alpha=x*PI,y=1-(cos(alpha)+1)/2,scalePart=SJ.PadCreator._getScalePart(x,scales),mx=x*scalePart.x+offsetPoint_x,my=y*scalePart.y+offsetPoint_y;points.push({x:mx,y:my})}{const p1=points[points.length-2],p2=points[points.length-1],diffX=p2.x-p1.x,diffY=p2.y-p1.y;var distance=dist(p1.x,p1.y,p2.x,p2.y),angle=atan2(diffY,diffX)}for(;angle>.2;){angle=max(.4*angle,.15);const p1=points[points.length-1],p2={x:cos(angle)*distance+p1.x,y:sin(angle)*distance+p1.y};points.push(p2)}angle=.07,distance=375*PAD_SCALE;const p1=points[points.length-1],p2={x:cos(angle)*distance+p1.x,y:sin(angle)*distance+p1.y};return points.push(p2),points},_getScalePart:(x,scales)=>{let dp=1/scales.length,p=dp,i=0,scale={x:0,y:0};for(i=0;i<scales.length&&(scale.x+=scales[i].x,scale.y+=scales[i].y,!(x<=p));i++)p+=dp;return scale},createParts:()=>{let parts=[];for(let i=1;i<PAD_COLLISION_POINTS.length;i++)parts.push(SJ.PadCreator.createOneBody(i-1,i));return parts},createOneBody:(p1_idx,p2_idx)=>{const p1=Matter.Vector.create(PAD_COLLISION_POINTS[p1_idx].x,PAD_COLLISION_POINTS[p1_idx].y),p2=Matter.Vector.create(PAD_COLLISION_POINTS[p2_idx].x,PAD_COLLISION_POINTS[p2_idx].y),vec=Matter.Vector.create(p2.x-p1.x,p2.y-p1.y),angle=atan2(vec.y,vec.x),mag=Matter.Vector.magnitude(vec),r=mag/SJ.PadCreator.SQRT_3;let body=Matter.Bodies.polygon(0,0,3,r);Matter.Body.setAngle(body,angle-HALF_PI);const translateVec=Matter.Vector.sub(p2,body.vertices[0]);return Matter.Body.translate(body,translateVec),body},createPadParts:()=>{let parts=[];for(let i=1;i<PAD_COLLISION_POINTS.length-1;i++){const p1=PAD_COLLISION_POINTS[i-1],p2=PAD_COLLISION_POINTS[i],part=new SJ.PadPart(p1,p2,SJ.PadCreator.padPartImg,130);parts.push(part)}const i=PAD_COLLISION_POINTS.length-1,p1=PAD_COLLISION_POINTS[i-1],p2=PAD_COLLISION_POINTS[i],part=new SJ.PadPart(p1,p2,SJ.PadCreator.padEndImg,375);return part.offset.y=-20*part.scale,parts.push(part),parts}};